-- VHDL Entity ece411.control.interface
--
-- Created:
--          by - sutrave1.ews (gelib-057-02.ews.illinois.edu)
--          at - 20:22:42 02/06/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY control IS
   PORT( 
      CheckN           : IN     std_logic;
      CheckP           : IN     std_logic;
      CheckZ           : IN     std_logic;
      MRESP_H          : IN     std_logic;
      Opcode           : IN     LC3b_opcode;
      RESET_L          : IN     std_logic;
      START_H          : IN     std_logic;
      clk              : IN     std_logic;
      imm_bit          : IN     std_logic;
      jsr_mode_bit     : IN     std_logic;
      mem_byte_sel     : IN     std_logic;
      n                : IN     std_logic;
      p                : IN     std_logic;
      shft_op          : IN     LC3b_shftop;
      z                : IN     std_logic;
      ADJMuxSel        : OUT    std_logic;
      ALUMuxSel        : OUT    std_logic;
      ALUop            : OUT    LC3b_aluop;
      ImmMuxSel        : OUT    std_logic;
      IndirectMuxSel   : OUT    std_logic;
      JmpMuxSel        : OUT    std_logic;
      LDBMuxSel        : OUT    std_logic;
      LEAMuxSel        : OUT    std_logic;
      LoadIR           : OUT    std_logic;
      LoadMAR          : OUT    std_logic;
      LoadMDR          : OUT    std_logic;
      LoadNZP          : OUT    std_logic;
      LoadPC           : OUT    std_logic;
      MARMuxSel        : OUT    std_logic;
      MDR2PCMuxSel     : OUT    std_logic;
      MDRMuxSel        : OUT    std_logic;
      MREAD_L          : OUT    std_logic;
      MWRITEH_L        : OUT    std_logic;
      MWRITEL_L        : OUT    std_logic;
      PC2RegFileMuxSel : OUT    std_logic;
      PCMuxSel         : OUT    std_logic;
      R7MuxSel         : OUT    std_logic;
      RFMuxSel         : OUT    std_logic;
      RegWrite         : OUT    std_logic;
      SEXT6MuxSel      : OUT    std_logic;
      StoreSR          : OUT    std_logic;
      TRAPMuxSel       : OUT    std_logic
   );

-- Declarations

END control ;

--
-- VHDL Architecture ece411.control.fsm
--
-- Created:
--          by - sutrave1.ews (gelib-057-02.ews.illinois.edu)
--          at - 20:22:42 02/06/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;
 
ARCHITECTURE fsm OF control IS

   TYPE STATE_TYPE IS (
      Reset,
      Decode,
      BR1,
      BR2,
      L_NOT,
      IF1,
      IF2,
      IF3,
      CalcAddr,
      ST1,
      LD1,
      ST2,
      LD2,
      ADD_reg,
      ADD_imm,
      L_AND_reg,
      L_AND_imm,
      JMP,
      LEA,
      JSR_offs,
      JSR_reg,
      LDB_1,
      LDB_2,
      LDB_3,
      LDI1,
      LDI2,
      LDI3,
      LDI4,
      LDI5,
      STI1,
      STI2,
      STI3,
      STI6,
      STI4,
      STI5,
      STB1,
      STB2,
      STB3,
      TRAP1,
      TRAP2,
      LDB_6,
      SHF_SLL,
      SHF_SRL,
      SHF_SRA,
      STB4,
      JSR_save_PC
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      RESET_L
   )
   -----------------------------------------------------------------
   BEGIN
      IF (RESET_L = '0') THEN
         current_state <= Reset;
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      CheckN,
      CheckP,
      CheckZ,
      MRESP_H,
      Opcode,
      START_H,
      current_state,
      imm_bit,
      jsr_mode_bit,
      mem_byte_sel,
      n,
      p,
      shft_op,
      z
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN Reset => 
            IF (START_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= Reset;
            END IF;
         WHEN Decode => 
            IF ((Opcode = op_add) AND (imm_bit = '1')) THEN 
               next_state <= ADD_imm;
            ELSIF ((Opcode = op_add) AND (imm_bit = '0')) THEN 
               next_state <= ADD_reg;
            ELSIF ((Opcode = op_and) AND (imm_bit = '0')) THEN 
               next_state <= L_AND_reg;
            ELSIF ((Opcode = op_and) AND (imm_bit = '1')) THEN 
               next_state <= L_AND_imm;
            ELSIF (Opcode = op_not) THEN 
               next_state <= L_NOT;
            ELSIF ((Opcode = op_ldr) OR
                   (Opcode = op_str)) THEN 
               next_state <= CalcAddr;
            ELSIF (Opcode = op_ldb) THEN 
               next_state <= LDB_1;
            ELSIF (Opcode = op_ldi) THEN 
               next_state <= LDI1;
            ELSIF (Opcode = op_sti) THEN 
               next_state <= STI1;
            ELSIF (Opcode = op_stb) THEN 
               next_state <= STB1;
            ELSIF (Opcode = op_trap) THEN 
               next_state <= TRAP1;
            ELSIF ((Opcode = op_shf) AND (shft_op = shft_sll)) THEN 
               next_state <= SHF_SLL;
            ELSIF ((Opcode = op_shf) AND (shft_op = shft_srl)) THEN 
               next_state <= SHF_SRL;
            ELSIF ((Opcode = op_shf) AND (shft_op = shft_sra)) THEN 
               next_state <= SHF_SRA;
            ELSIF (Opcode = op_br) THEN 
               next_state <= BR1;
            ELSIF (Opcode = op_jmp) THEN 
               next_state <= JMP;
            ELSIF (Opcode = op_lea) THEN 
               next_state <= LEA;
            ELSIF (Opcode = op_jsr) THEN 
               next_state <= JSR_save_PC;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN BR1 => 
            IF (( (n AND CheckN)  OR
                  (p AND CheckP)  OR
                  (z AND CheckZ) ) = '1') THEN 
               next_state <= BR2;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN BR2 => 
            next_state <= IF1;
         WHEN L_NOT => 
            next_state <= IF1;
         WHEN IF1 => 
            next_state <= IF2;
         WHEN IF2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF3;
            ELSE
               next_state <= IF2;
            END IF;
         WHEN IF3 => 
            next_state <= Decode;
         WHEN CalcAddr => 
            IF (Opcode = op_str) THEN 
               next_state <= ST1;
            ELSIF (Opcode = op_ldr) THEN 
               next_state <= LD1;
            ELSE
               next_state <= CalcAddr;
            END IF;
         WHEN ST1 => 
            next_state <= ST2;
         WHEN LD1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LD2;
            ELSE
               next_state <= LD1;
            END IF;
         WHEN ST2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= ST2;
            END IF;
         WHEN LD2 => 
            next_state <= IF1;
         WHEN ADD_reg => 
            next_state <= IF1;
         WHEN ADD_imm => 
            next_state <= IF1;
         WHEN L_AND_reg => 
            next_state <= IF1;
         WHEN L_AND_imm => 
            next_state <= IF1;
         WHEN JMP => 
            next_state <= IF1;
         WHEN LEA => 
            next_state <= IF1;
         WHEN JSR_offs => 
            next_state <= IF1;
         WHEN JSR_reg => 
            next_state <= IF1;
         WHEN LDB_1 => 
            next_state <= LDB_2;
         WHEN LDB_2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LDB_3;
            ELSE
               next_state <= LDB_2;
            END IF;
         WHEN LDB_3 => 
            next_state <= IF1;
         WHEN LDI1 => 
            next_state <= LDI2;
         WHEN LDI2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LDI3;
            ELSE
               next_state <= LDI2;
            END IF;
         WHEN LDI3 => 
            next_state <= LDI4;
         WHEN LDI4 => 
            IF (MRESP_H  = '1') THEN 
               next_state <= LDI5;
            ELSE
               next_state <= LDI4;
            END IF;
         WHEN LDI5 => 
            next_state <= IF1;
         WHEN STI1 => 
            next_state <= STI2;
         WHEN STI2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= STI3;
            ELSE
               next_state <= STI2;
            END IF;
         WHEN STI3 => 
            next_state <= STI4;
         WHEN STI6 => 
            next_state <= IF1;
         WHEN STI4 => 
            next_state <= STI5;
         WHEN STI5 => 
            IF (MRESP_H  = '1') THEN 
               next_state <= STI6;
            ELSE
               next_state <= STI5;
            END IF;
         WHEN STB1 => 
            next_state <= STB2;
         WHEN STB2 => 
            IF (mem_byte_sel = '0') THEN 
               next_state <= STB3;
            ELSIF (mem_byte_sel = '1') THEN 
               next_state <= STB4;
            ELSE
               next_state <= STB2;
            END IF;
         WHEN STB3 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STB3;
            END IF;
         WHEN TRAP1 => 
            next_state <= TRAP2;
         WHEN TRAP2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LDB_6;
            ELSE
               next_state <= TRAP2;
            END IF;
         WHEN LDB_6 => 
            next_state <= IF1;
         WHEN SHF_SLL => 
            next_state <= IF1;
         WHEN SHF_SRL => 
            next_state <= IF1;
         WHEN SHF_SRA => 
            next_state <= IF1;
         WHEN STB4 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STB4;
            END IF;
         WHEN JSR_save_PC => 
            IF (jsr_mode_bit = '0') THEN 
               next_state <= JSR_reg;
            ELSIF (jsr_mode_bit = '1') THEN 
               next_state <= JSR_offs;
            ELSE
               next_state <= JSR_save_PC;
            END IF;
         WHEN OTHERS =>
            next_state <= Reset;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      ADJMuxSel <= '0';
      ALUMuxSel <= '0';
      ALUop <= "000";
      ImmMuxSel <= '0';
      IndirectMuxSel <= '0';
      JmpMuxSel <= '0';
      LDBMuxSel <= '0';
      LEAMuxSel <= '0';
      LoadIR <= '0';
      LoadMAR <= '0';
      LoadMDR <= '0';
      LoadNZP <= '0';
      LoadPC <= '0';
      MARMuxSel <= '0';
      MDR2PCMuxSel <= '0';
      MDRMuxSel <= '0';
      MREAD_L <= '1';
      MWRITEH_L <= '1';
      MWRITEL_L <= '1';
      PC2RegFileMuxSel <= '0';
      PCMuxSel <= '0';
      R7MuxSel <= '0';
      RFMuxSel <= '0';
      RegWrite <= '0';
      SEXT6MuxSel <= '0';
      StoreSR <= '1';
      TRAPMuxSel <= '0';

      -- Combined Actions
      CASE current_state IS
         WHEN BR2 => 
            PCMuxSel  <= '1';
            LoadPC <= '1';
         WHEN L_NOT => 
            ALUop <= alu_not;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN IF1 => 
            LoadMAR <= '1';
            LoadPC <= '1';
         WHEN IF2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN IF3 => 
            LoadIR <= '1';
         WHEN CalcAddr => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
         WHEN ST1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN LD1 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN ST2 => 
            MWRITEL_L <= '0' after 6 ns;
            MWRITEH_L <= '0' after 6 ns;
         WHEN LD2 => 
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN ADD_reg => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN ADD_imm => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1'; 
            ImmMuxSel <= '1';
         WHEN L_AND_reg => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN L_AND_imm => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ImmMuxSel <= '1';
         WHEN JMP => 
            ALUop <= alu_pass;
            JmpMuxSel <= '1';
            LoadPC <= '1';
         WHEN LEA => 
            LEAMuxSel <= '1';
            RFMuxSel <= '1';
            RegWrite <= '1';
            StoreSR <= '0';
            LoadNZP <= '1';
         WHEN JSR_offs => 
            ADJMuxSel <= '1';
            PCMuxSel <= '1';
            LoadPC <= '1';
         WHEN JSR_reg => 
            ALUop <= alu_pass;
            JmpMuxSel <= '1';
            LoadPC <= '1';
         WHEN LDB_1 => 
            SEXT6MuxSel <= '1';
            ALUMuxSel  <= '1';
            ALUop  <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
         WHEN LDB_2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN LDB_3 => 
            StoreSR <= '0';
            RegWrite <='1';
            LDBMuxSel <= '1';
            LoadNZP <= '1';
         WHEN LDI1 => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
         WHEN LDI2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN LDI3 => 
            LoadMAR <= '1';
            IndirectMuxSel <='1';
         WHEN LDI4 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN LDI5 => 
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN STI1 => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
         WHEN STI2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN STI3 => 
            LoadMAR <= '1';
            IndirectMuxSel <='1';
         WHEN STI6 => 
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN STI4 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN STI5 => 
            MWRITEL_L <= '0' after 6 ns;
            MWRITEH_L <= '0' after 6 ns;
         WHEN STB1 => 
            SEXT6MuxSel <= '1';
            ALUMuxSel  <= '1';
            ALUop  <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
         WHEN STB2 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN STB3 => 
            MWRITEL_L <= '0' after 6 ns;
         WHEN TRAP1 => 
            -- R7 <= PC
            R7MuxSel <= '1';
            StoreSR <= '0';
            RegWrite <= '1';
            PC2RegFileMuxSel <= '1';
            LEAMuxSel <= '1';
            RFMuxSel <= '1';
            
            --MAR <= ZEXT(trapvect8) << 1
            TRAPMuxSel <= '1';
            LoadMAR <= '1';
         WHEN TRAP2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN LDB_6 => 
            MDR2PCMuxSel <= '1';
            LoadPC <= '1';
         WHEN SHF_SLL => 
            ALUop <= alu_sll;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN SHF_SRL => 
            ALUop <= alu_srl;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN SHF_SRA => 
            ALUop <= alu_sra;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN STB4 => 
            MWRITEH_L <= '0' after 6 ns;
         WHEN JSR_save_PC => 
            R7MuxSel <= '1';
            RegWrite <=  '1';
            RFMuxSel <= '1';
            LEAMuxSel <= '1';
            PC2RegFileMuxSel <= '1';
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
